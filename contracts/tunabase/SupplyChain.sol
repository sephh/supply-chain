pragma solidity >=0.5.1;

import "../tunaaccesscontrol/FisherRole.sol";
import "../tunaaccesscontrol/RegulatorRole.sol";
import "../tunaaccesscontrol/ProcessorRole.sol";
import "../tunaaccesscontrol/DistributorRole.sol";
import "../tunaaccesscontrol/ConsumerRole.sol";

// Define a contract 'Supplychain'
contract SupplyChain is FisherRole, RegulatorRole, ProcessorRole, DistributorRole, ConsumerRole {

	// Define 'owner'
	address payable owner;

	// Define a variable called 'upc' for Universal Product Code (UPC)
	uint  upc;

	// Define a variable called 'sku' for Stock Keeping Unit (SKU)
	uint  sku;

	// Define a public mapping 'items' that maps the UPC to an Item.
	mapping(uint => Item) items;

	// Define a public mapping 'itemsHistory' that maps the UPC to an array of TxHash,
	// that track its journey through the supply chain -- to be sent from DApp.
	mapping(uint => string[]) itemsHistory;

	// Define enum 'State' with the following values:
	enum State
	{
		Catched, // 0
		Approved, // 1
		Landed, // 2
		Processed, // 3
		Packed, // 4
		ForSale, // 5
		Sold // 6
	}

	State constant defaultState = State.Catched;

	// Define a struct 'Item' with the following fields:
	struct Item {
		uint sku;  // Stock Keeping Unit (SKU)
		uint upc; // Universal Product Code (UPC), generated by the Farmer, goes on the package, can be verified by the Consumer
		address ownerID;  // Metamask-Ethereum address of the current owner as the product moves through 8 stages
		address originFisherID; // Metamask-Ethereum address of the Fisher
		string originFisherName; // Fisher Name
		string originFisherInformation;  // Fisher Information
		string originFisherLatitude; // Fisher Latitude
		string originFisherLongitude;  // Fisher Longitude
		uint productID;  // Product ID potentially a combination of upc + sku
		string productNotes; // Product Notes
		uint productPrice; // Product Price
		State itemState;  // Product State as represented in the enum above
		address regulatorID;  // Metamask-Ethereum address of the Regulator
		address processorID; // Metamask-Ethereum address of the Processor
		address distributorID; // Metamask-Ethereum address of the Distributor
		address payable consumerID; // Metamask-Ethereum address of the Consumer
	}

	// Define 8 events with the same 8 state values and accept 'upc' as input argument
	event Catched(uint upc);
	event Approved(uint upc);
	event Landed(uint upc);
	event Processed(uint upc);
	event Packed(uint upc);
	event ForSale(uint upc);
	event Sold(uint upc);
	//	event Shipped(uint upc);
	//	event Received(uint upc);
	//	event Purchased(uint upc);

	// Define a modifer that checks to see if msg.sender == owner of the contract
	modifier onlyOwner() {
		require(msg.sender == owner);
		_;
	}

	modifier verifyUpc(uint _upc) {
		require(items[_upc].upc != _upc);
		_;
	}

	// Define a modifer that verifies the Caller
	modifier verifyCaller (address _address) {
		require(msg.sender == _address);
		_;
	}

	// Define a modifier that checks if the paid amount is sufficient to cover the price
	modifier paidEnough(uint _price) {
		require(msg.value >= _price);
		_;
	}

	// Define a modifier that checks the price and refunds the remaining balance
	modifier checkValue(uint _upc) {
		_;
		uint _price = items[_upc].productPrice;
		uint amountToReturn = msg.value - _price;
		items[_upc].consumerID.transfer(amountToReturn);
	}

	// Define a modifier that checks if an item.state of a upc is Catched
	modifier catched(uint _upc) {
		require(items[_upc].itemState == State.Catched);
		_;
	}

	// Define a modifier that checks if an item.state of a upc is Approved
	modifier approved(uint _upc) {
		require(items[_upc].itemState == State.Approved);
		_;
	}

	// Define a modifier that checks if an item.state of a upc is Landed
	modifier landed(uint _upc) {
		require(items[_upc].itemState == State.Landed);
		_;
	}

	// Define a modifier that checks if an item.state of a upc is Processed
	modifier processed(uint _upc) {
		require(items[_upc].itemState == State.Processed);
		_;
	}

	// Define a modifier that checks if an item.state of a upc is Packed
	modifier packed(uint _upc) {
		require(items[_upc].itemState == State.Packed);
		_;
	}

	// Define a modifier that checks if an item.state of a upc is ForSale
	modifier forSale(uint _upc) {
		require(items[_upc].itemState == State.ForSale);
		_;
	}

	// Define a modifier that checks if an item.state of a upc is Sold
	modifier sold(uint _upc) {
		require(items[_upc].itemState == State.Sold);
		_;
	}

	// In the constructor set 'owner' to the address that instantiated the contract
	// and set 'sku' to 1
	// and set 'upc' to 1
	constructor() public payable {
		owner = msg.sender;
		sku = 1;
		upc = 1;
	}

	// Define a function 'kill' if required
	function kill() public {
		if (msg.sender == owner) {
			selfdestruct(owner);
		}
	}

	// Define a function 'catchFish' that allows a fisher to mark an item 'Catched'
	function catchFish(
		uint _upc,
		address _originFisherID,
		string memory _originFisherName,
		string memory _originFisherInformation,
		string memory _originFisherLatitude,
		string memory _originFisherLongitude,
		string memory _productNotes
	) verifyUpc() onlyFisher() public
	{
		// Add the new item as part of Catch
		items[_upc].sku = sku;
		items[_upc].upc = _upc;
		items[_upc].ownerID = _originFisherID;
		items[_upc].originFisherID = _originFisherID;
		items[_upc].originFisherName = _originFisherName;
		items[_upc].originFisherInformation = _originFisherInformation;
		items[_upc].originFisherLatitude = _originFisherLatitude;
		items[_upc].originFisherLongitude = _originFisherLongitude;
		items[_upc].productID = _upc + sku;
		items[_upc].productNotes = _productNotes;
		items[_upc].itemState = State.Catched;

		// Increment sku
		sku = sku + 1;
		// Emit the appropriate event
		emit Catched(_upc);
	}

	// Define a function 'processtItem' that allows a farmer to mark an item 'Processed'
	function processItem(uint _upc) public
		// Call modifier to check if upc has passed previous supply chain stage

		// Call modifier to verify caller of this function

	{
		// Update the appropriate fields

		// Emit the appropriate event

	}

	// Define a function 'packItem' that allows a farmer to mark an item 'Packed'
	function packItem(uint _upc) public
		// Call modifier to check if upc has passed previous supply chain stage

		// Call modifier to verify caller of this function

	{
		// Update the appropriate fields

		// Emit the appropriate event

	}

	// Define a function 'sellItem' that allows a farmer to mark an item 'ForSale'
	function sellItem(uint _upc, uint _price) public
		// Call modifier to check if upc has passed previous supply chain stage

		// Call modifier to verify caller of this function

	{
		// Update the appropriate fields

		// Emit the appropriate event

	}

	// Define a function 'buyItem' that allows the disributor to mark an item 'Sold'
	// Use the above defined modifiers to check if the item is available for sale, if the buyer has paid enough,
	// and any excess ether sent is refunded back to the buyer
	function buyItem(uint _upc) public payable
		// Call modifier to check if upc has passed previous supply chain stage

		// Call modifer to check if buyer has paid enough

		// Call modifer to send any excess ether back to buyer

	{

		// Update the appropriate fields - ownerID, distributorID, itemState

		// Transfer money to farmer

		// emit the appropriate event

	}

	// Define a function 'shipItem' that allows the distributor to mark an item 'Shipped'
	// Use the above modifers to check if the item is sold
	function shipItem(uint _upc) public
		// Call modifier to check if upc has passed previous supply chain stage

		// Call modifier to verify caller of this function

	{
		// Update the appropriate fields

		// Emit the appropriate event

	}

	// Define a function 'receiveItem' that allows the retailer to mark an item 'Received'
	// Use the above modifiers to check if the item is shipped
	function receiveItem(uint _upc) public
		// Call modifier to check if upc has passed previous supply chain stage

		// Access Control List enforced by calling Smart Contract / DApp
	{
		// Update the appropriate fields - ownerID, retailerID, itemState

		// Emit the appropriate event

	}

	// Define a function 'purchaseItem' that allows the consumer to mark an item 'Purchased'
	// Use the above modifiers to check if the item is received
	function purchaseItem(uint _upc) public
		// Call modifier to check if upc has passed previous supply chain stage

		// Access Control List enforced by calling Smart Contract / DApp
	{
		// Update the appropriate fields - ownerID, consumerID, itemState

		// Emit the appropriate event

	}

	// Define a function 'fetchItemBufferOne' that fetches the data
	function fetchItemBufferOne(uint _upc) public view returns
	(
		uint itemSKU,
		uint itemUPC,
		address ownerID,
		address originFarmerID,
		string memory originFarmName,
		string memory originFarmInformation,
		string memory originFarmLatitude,
		string memory originFarmLongitude
	)
	{
		// Assign values to the 8 parameters

		return
		(
		itemSKU,
		itemUPC,
		ownerID,
		originFarmerID,
		originFarmName,
		originFarmInformation,
		originFarmLatitude,
		originFarmLongitude
		);
	}

	// Define a function 'fetchItemBufferTwo' that fetches the data
	function fetchItemBufferTwo(uint _upc) public view returns
	(
		uint itemSKU,
		uint itemUPC,
		uint productID,
		string memory productNotes,
		uint productPrice,
		uint itemState,
		address distributorID,
		address retailerID,
		address consumerID
	)
	{
		// Assign values to the 9 parameters


		return
		(
		itemSKU,
		itemUPC,
		productID,
		productNotes,
		productPrice,
		itemState,
		distributorID,
		retailerID,
		consumerID
		);
	}
}
