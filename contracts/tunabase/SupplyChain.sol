pragma solidity >=0.5.1;

import "../tunaaccesscontrol/FisherRole.sol";
import "../tunaaccesscontrol/RegulatorRole.sol";
import "../tunaaccesscontrol/ProcessorRole.sol";
import "../tunaaccesscontrol/DistributorRole.sol";
import "../tunaaccesscontrol/ConsumerRole.sol";
import "../tunacore/Ownable.sol";

// Define a contract 'Supplychain'
contract SupplyChain is Ownable, FisherRole, RegulatorRole, ProcessorRole, DistributorRole, ConsumerRole {

	// Define 'owner'
	address payable owner;

	// Define a variable called 'upc' for Universal Product Code (UPC)
	uint  upc;

	// Define a variable called 'sku' for Stock Keeping Unit (SKU)
	uint  sku;

	// Define a public mapping 'items' that maps the UPC to an Item.
	mapping(uint => Item) items;

	// Define a public mapping 'itemsHistory' that maps the UPC to an array of TxHash,
	// that track its journey through the supply chain -- to be sent from DApp.
	mapping(uint => string[]) itemsHistory;

	// Define enum 'State' with the following values:
	enum State
	{
		Catched, // 0
		Approved, // 1
		Landed, // 2
		Processed, // 3
		Packed, // 4
		ForSale, // 5
		Sold // 6
	}

	State constant defaultState = State.Catched;

	// Define a struct 'Item' with the following fields:
	struct Item {
		uint sku;  // Stock Keeping Unit (SKU)
		uint upc; // Universal Product Code (UPC), generated by the Fisher, goes on the package, can be verified by the Consumer
		address ownerID;  // Metamask-Ethereum address of the current owner as the product moves through 8 stages
		address payable originFisherID; // Metamask-Ethereum address of the Fisher
		string originFisherName; // Fisher Name
		string originFisherInformation;  // Fisher Information
		string originFisherLatitude; // Fisher Latitude
		string originFisherLongitude;  // Fisher Longitude
		uint productID;  // Product ID potentially a combination of upc + sku
		string productNotes; // Product Notes
		uint productPrice; // Product Price
		State itemState;  // Product State as represented in the enum above
		address regulatorID;  // Metamask-Ethereum address of the Regulator
		address processorID; // Metamask-Ethereum address of the Processor
		address distributorID; // Metamask-Ethereum address of the Distributor
		address payable consumerID; // Metamask-Ethereum address of the Consumer
	}

	// Define 8 events with the same 8 state values and accept 'upc' as input argument
	event Catched(uint upc);
	event Approved(uint upc);
	event Landed(uint upc);
	event Processed(uint upc);
	event Packed(uint upc);
	event ForSale(uint upc);
	event Sold(uint upc);
	//	event Shipped(uint upc);
	//	event Received(uint upc);
	//	event Purchased(uint upc);

	// Define a modifer that checks to see if msg.sender == owner of the contract
	modifier onlyOwner() {
		require(msg.sender == owner, 'You need to be a owner to perform this action.');
		_;
	}

	modifier verifyUpc(uint _upc) {
		require(items[_upc].upc != _upc, 'This fish already exists.');
		_;
	}

	// Define a modifer that verifies the Caller
	modifier verifyCaller (address _address) {
		require(msg.sender == _address, 'Invalid Caller.');
		_;
	}

	// Define a modifier that checks if the paid amount is sufficient to cover the price
	modifier paidEnough(uint _price) {
		require(msg.value >= _price, 'Doesn\'t pay enough');
		_;
	}

	// Define a modifier that checks the price and refunds the remaining balance
	modifier checkValue(uint _upc) {
		_;
		uint _price = items[_upc].productPrice;
		uint amountToReturn = msg.value - _price;
		items[_upc].consumerID.transfer(amountToReturn);
	}

	// Define a modifier that checks if an item.state of a upc is Catched
	modifier catched(uint _upc) {
		require(items[_upc].itemState == State.Catched, 'Not catched');
		_;
	}

	// Define a modifier that checks if an item.state of a upc is Approved
	modifier approved(uint _upc) {
		require(items[_upc].itemState == State.Approved, 'Not approved');
		_;
	}

	// Define a modifier that checks if an item.state of a upc is Landed
	modifier landed(uint _upc) {
		require(items[_upc].itemState == State.Landed, 'Not landed');
		_;
	}

	// Define a modifier that checks if an item.state of a upc is Processed
	modifier processed(uint _upc) {
		require(items[_upc].itemState == State.Processed, 'Not processed');
		_;
	}

	// Define a modifier that checks if an item.state of a upc is Packed
	modifier packed(uint _upc) {
		require(items[_upc].itemState == State.Packed, 'Not packed');
		_;
	}

	// Define a modifier that checks if an item.state of a upc is ForSale
	modifier forSale(uint _upc) {
		require(items[_upc].itemState == State.ForSale, 'Not for sale');
		_;
	}

	// Define a modifier that checks if an item.state of a upc is Sold
	modifier sold(uint _upc) {
		require(items[_upc].itemState == State.Sold, 'Not sold');
		_;
	}

	// In the constructor set 'owner' to the address that instantiated the contract
	// and set 'sku' to 1
	// and set 'upc' to 1
	constructor() public payable {
		owner = msg.sender;
		sku = 1;
		upc = 1;
	}

	// Define a function 'kill' if required
	function kill() public {
		if (msg.sender == owner) {
			selfdestruct(owner);
		}
	}

	// Define a function 'catchFish' that allows a fisher to mark an item 'Catched'
	function catchFish(
		uint _upc,
		address payable _originFisherID,
		string memory _originFisherName,
		string memory _originFisherInformation,
		string memory _originFisherLatitude,
		string memory _originFisherLongitude,
		string memory _productNotes
	) verifyUpc(_upc) onlyFisher() public
	{
		// Add the new item as part of Catch
		items[_upc].sku = sku;
		items[_upc].upc = _upc;
		items[_upc].ownerID = _originFisherID;
		items[_upc].originFisherID = _originFisherID;
		items[_upc].originFisherName = _originFisherName;
		items[_upc].originFisherInformation = _originFisherInformation;
		items[_upc].originFisherLatitude = _originFisherLatitude;
		items[_upc].originFisherLongitude = _originFisherLongitude;
		items[_upc].productID = _upc + sku;
		items[_upc].productNotes = _productNotes;
		items[_upc].itemState = State.Catched;

		// Increment sku
		sku = sku + 1;
		// Emit the appropriate event
		emit Catched(_upc);
	}

	// Define a function 'approve' that allows a regulator to mark an item 'Approved'
	function approve(uint _upc) catched(_upc) onlyRegulator() public
	{
		items[_upc].regulatorID = msg.sender;
		items[_upc].itemState = State.Approved;

		emit Approved(_upc);
	}

	// Define a function 'landFish' that allows a fisher to mark an item 'Landed'
	function landFish(uint _upc) approved(_upc) onlyFisher() public
	{
		items[_upc].itemState = State.Landed;

		emit Landed(_upc);
	}

	// Define a function 'processFish' that allows a processor to mark an item 'Processed'
	function processFish(uint _upc) landed(_upc) onlyProcessor() public {
		items[_upc].processorID = msg.sender;
		items[_upc].itemState = State.Processed;

		emit Processed(_upc);
	}

	// Define a function 'packFish' that allows a processor to mark an item 'Packed'
	function packFish(uint _upc) processed(_upc) onlyProcessor() public {
		items[_upc].processorID = msg.sender;
		items[_upc].itemState = State.Packed;

		emit Packed(_upc);
	}

	// Define a function 'sellFish' that allows a distributor to mark an item 'ForSale'
	function sellFish(uint _upc, uint _price) packed(_upc) onlyDistributor() public
	{
		items[_upc].distributorID = msg.sender;
		items[_upc].productPrice = _price;
		items[_upc].itemState = State.ForSale;

		emit ForSale(_upc);

	}

	// Define a function 'buyItem' that allows the disributor to mark an item 'Sold'
	// Use the above defined modifiers to check if the item is available for sale, if the buyer has paid enough,
	// and any excess ether sent is refunded back to the buyer
	function buyItem(uint _upc) forSale(_upc) paidEnough(items[_upc].productPrice) checkValue(_upc) public payable {
		address payable consumer = msg.sender;
		uint price = items[_upc].productPrice;

		// Update the appropriate fields - ownerID, itemState
		items[_upc].ownerID = consumer;
		items[_upc].consumerID = consumer;
		items[_upc].itemState = State.Sold;

		// Transfer money to farmer
		items[_upc].originFisherID.transfer(price);

		// emit the appropriate event
		emit Sold(_upc);
	}

	// Define a function 'fetchItemBufferOne' that fetches the data
	function fetchItemBufferOne(uint _upc) public view returns
	(
		uint itemSKU,
		uint itemUPC,
		address ownerID,
		address originFisherID,
		string memory originFisherName,
		string memory originFisherInformation,
		string memory originFisherLatitude,
		string memory originFisherLongitude
	)
	{
		// Assign values to the 8 parameters
		itemSKU = items[_upc].sku;
		itemUPC = items[_upc].upc;
		ownerID = items[_upc].ownerID;
		originFisherID = items[_upc].originFisherID;
		originFisherName = items[_upc].originFisherName;
		originFisherInformation = items[_upc].originFisherInformation;
		originFisherLatitude = items[_upc].originFisherLatitude;
		originFisherLongitude = items[_upc].originFisherLongitude;

		return
		(
		itemSKU,
		itemUPC,
		ownerID,
		originFisherID,
		originFisherName,
		originFisherInformation,
		originFisherLatitude,
		originFisherLongitude
		);
	}

	// Define a function 'fetchItemBufferTwo' that fetches the data
	function fetchItemBufferTwo(uint _upc) public view returns
	(
		uint itemSKU,
		uint itemUPC,
		uint productID,
		string memory productNotes,
		uint productPrice,
		uint itemState,
		address distributorID,
		address consumerID,
		address regulatorID,
		address processorID
	)
	{
		// Assign values to the 8 parameters
		itemSKU = items[_upc].sku;
		itemUPC = items[_upc].upc;
		productID = items[_upc].productID;
		productNotes = items[_upc].productNotes;
		productPrice = items[_upc].productPrice;
		itemState = uint(items[_upc].itemState);
		distributorID = items[_upc].distributorID;
		consumerID = items[_upc].consumerID;
		regulatorID = items[_upc].regulatorID;
		processorID = items[_upc].processorID;

		return
		(
		itemSKU,
		itemUPC,
		productID,
		productNotes,
		productPrice,
		itemState,
		distributorID,
		consumerID,
		regulatorID,
		processorID
		);
	}
}
